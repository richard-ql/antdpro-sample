import format from './format';
import { useEffect, useMemo, useRef, useState, } from 'react';
const createMatchMediaPolyfill = (matches, media) => ({
    matches,
    media,
    addListener() { },
    removeListener() { },
});
const createMatchMedia = (props, ref, prevRef) => {
    const defaultMatches = props.defaultMatches || false;
    const query = props.query || '';
    const targetWindow = props.targetWindow || window;
    const warn = 
    // tslint:disable-next-line no-console
    ['production', 'test'].includes(process && process.env.NODE_ENV) && console && console.warn;
    prevRef.current = ref.current;
    if (typeof targetWindow !== 'object') {
        // tslint:disable-next-line no-unused-expression
        warn && warn(`[UseMedia] Invalid \`targetWindow\``);
    }
    else if (typeof targetWindow.matchMedia !== 'function') {
        // tslint:disable-next-line no-unused-expression
        warn && warn(`[UseMedia] Current \`targetWindow\` doesn't support \`matchMedia\` API.`);
    }
    else {
        return (ref.current = targetWindow.matchMedia(format(query))) && void 0;
    }
    ref.current = createMatchMediaPolyfill(defaultMatches, format(query));
};
const useMediaStorage = new Map();
const useMedia = (initialProps = {}) => {
    const listenRef = useRef(false);
    const setPropsRef = useRef();
    const mediaQueryListRef = useRef(void 0);
    const prevMediaQueryListRef = useRef(mediaQueryListRef.current);
    const useMediaPropsRef = useRef(Object.assign({}, initialProps));
    useState(() => {
        createMatchMedia(useMediaPropsRef.current, mediaQueryListRef, prevMediaQueryListRef);
        useMediaPropsRef.current.defaultMatches = mediaQueryListRef.current.matches;
        setPropsRef.current = (nextProps = {}) => {
            if (typeof nextProps === 'function')
                useMediaPropsRef.current = nextProps(useMediaPropsRef.current) || {};
            else
                useMediaPropsRef.current = nextProps;
            createMatchMedia(useMediaPropsRef.current, mediaQueryListRef, prevMediaQueryListRef);
            setMatches(mediaQueryListRef.current.matches);
        };
    });
    const [matches, setMatches] = useState(useMediaPropsRef.current.defaultMatches);
    const eventListener = () => {
        if (!listenRef.current || useMediaPropsRef.current.paused)
            return;
        if (useMediaPropsRef.current.onChange) {
            if (useMediaPropsRef.current.onChange(mediaQueryListRef.current.matches))
                return;
        }
        setMatches(mediaQueryListRef.current.matches);
    };
    useEffect(() => {
        if (prevMediaQueryListRef.current) {
            prevMediaQueryListRef.current.removeListener(eventListener);
        }
        listenRef.current = true;
        mediaQueryListRef.current.addListener(eventListener);
        return () => {
            listenRef.current = false;
            mediaQueryListRef.current.removeListener(eventListener);
        };
    }, [mediaQueryListRef.current]);
    useMemo(() => {
        useMediaStorage.set(useMediaPropsRef.current.id, [matches, setPropsRef.current]);
    }, [matches]);
    return [matches, setPropsRef.current];
};
export default useMedia;
export const getUseMedia = (id) => useMediaStorage.get(id);
