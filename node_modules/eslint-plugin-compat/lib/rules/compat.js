"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Lint = _interopRequireWildcard(require("../Lint"));

var _Versioning = _interopRequireWildcard(require("../Versioning"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function getName(node) {
  switch (node.type) {
    case 'NewExpression':
      {
        return node.callee.name;
      }

    case 'MemberExpression':
      {
        return node.object.name;
      }

    case 'CallExpression':
      {
        return node.callee.name;
      }

    default:
      throw new Error('not found');
  }
}

var _default = {
  meta: {
    docs: {
      description: 'Ensure cross-browser API compatibility',
      category: 'Compatibility',
      recommended: true
    },
    fixable: 'code',
    schema: []
  },

  create(context) {
    // Determine lowest targets from browserslist config, which reads user's
    const browserslistConfig = context.settings.browsers || context.settings.targets || context.options[0];
    const browserslistTargets = (0, _Versioning.Versioning)((0, _Versioning.default)(context.getFilename(), browserslistConfig));
    const errors = [];

    function lint(node) {
      const {
        isValid,
        rule,
        unsupportedTargets
      } = (0, _Lint.default)(node, browserslistTargets, new Set(context.settings.polyfills || []));

      if (!isValid) {
        errors.push({
          node,
          message: [(0, _Lint.generateErrorName)(rule), 'is not supported in', unsupportedTargets.join(', ')].join(' ')
        });
      }
    }

    const identifiers = new Set();
    return {
      CallExpression: lint,
      MemberExpression: lint,
      NewExpression: lint,

      // Keep track of all the defined variables. Do not report errors for nodes that are not defined
      Identifier(node) {
        if (node.parent) {
          const {
            type
          } = node.parent;

          if ( // ex. const { Set } = require('immutable');
          type === 'Property' || // ex. function Set() {}
          type === 'FunctionDeclaration' || // ex. const Set = () => {}
          type === 'VariableDeclarator' || // ex. class Set {}
          type === 'ClassDeclaration' || // ex. import Set from 'set';
          type === 'ImportDefaultSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportDeclaration') {
            identifiers.add(node.name);
          }
        }
      },

      'Program:exit': () => {
        // Get a map of all the variables defined in the root scope (not the global scope)
        // const variablesMap = context.getScope().childScopes.map(e => e.set)[0];
        errors.filter(error => !identifiers.has(getName(error.node))).forEach(node => context.report(node));
      }
    };
  }

};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9jb21wYXQuanMiXSwibmFtZXMiOlsiZ2V0TmFtZSIsIm5vZGUiLCJ0eXBlIiwiY2FsbGVlIiwibmFtZSIsIm9iamVjdCIsIkVycm9yIiwibWV0YSIsImRvY3MiLCJkZXNjcmlwdGlvbiIsImNhdGVnb3J5IiwicmVjb21tZW5kZWQiLCJmaXhhYmxlIiwic2NoZW1hIiwiY3JlYXRlIiwiY29udGV4dCIsImJyb3dzZXJzbGlzdENvbmZpZyIsInNldHRpbmdzIiwiYnJvd3NlcnMiLCJ0YXJnZXRzIiwib3B0aW9ucyIsImJyb3dzZXJzbGlzdFRhcmdldHMiLCJnZXRGaWxlbmFtZSIsImVycm9ycyIsImxpbnQiLCJpc1ZhbGlkIiwicnVsZSIsInVuc3VwcG9ydGVkVGFyZ2V0cyIsIlNldCIsInBvbHlmaWxscyIsInB1c2giLCJtZXNzYWdlIiwiam9pbiIsImlkZW50aWZpZXJzIiwiQ2FsbEV4cHJlc3Npb24iLCJNZW1iZXJFeHByZXNzaW9uIiwiTmV3RXhwcmVzc2lvbiIsIklkZW50aWZpZXIiLCJwYXJlbnQiLCJhZGQiLCJmaWx0ZXIiLCJlcnJvciIsImhhcyIsImZvckVhY2giLCJyZXBvcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFDQTs7OztBQWlCQSxTQUFTQSxPQUFULENBQWlCQyxJQUFqQixFQUF1QjtBQUNyQixVQUFRQSxJQUFJLENBQUNDLElBQWI7QUFDRSxTQUFLLGVBQUw7QUFBc0I7QUFDcEIsZUFBT0QsSUFBSSxDQUFDRSxNQUFMLENBQVlDLElBQW5CO0FBQ0Q7O0FBQ0QsU0FBSyxrQkFBTDtBQUF5QjtBQUN2QixlQUFPSCxJQUFJLENBQUNJLE1BQUwsQ0FBWUQsSUFBbkI7QUFDRDs7QUFDRCxTQUFLLGdCQUFMO0FBQXVCO0FBQ3JCLGVBQU9ILElBQUksQ0FBQ0UsTUFBTCxDQUFZQyxJQUFuQjtBQUNEOztBQUNEO0FBQ0UsWUFBTSxJQUFJRSxLQUFKLENBQVUsV0FBVixDQUFOO0FBWEo7QUFhRDs7ZUFVYztBQUNiQyxFQUFBQSxJQUFJLEVBQUU7QUFDSkMsSUFBQUEsSUFBSSxFQUFFO0FBQ0pDLE1BQUFBLFdBQVcsRUFBRSx3Q0FEVDtBQUVKQyxNQUFBQSxRQUFRLEVBQUUsZUFGTjtBQUdKQyxNQUFBQSxXQUFXLEVBQUU7QUFIVCxLQURGO0FBTUpDLElBQUFBLE9BQU8sRUFBRSxNQU5MO0FBT0pDLElBQUFBLE1BQU0sRUFBRTtBQVBKLEdBRE87O0FBVWJDLEVBQUFBLE1BQU0sQ0FBQ0MsT0FBRCxFQUEyQjtBQUMvQjtBQUVBLFVBQU1DLGtCQUFxQyxHQUN6Q0QsT0FBTyxDQUFDRSxRQUFSLENBQWlCQyxRQUFqQixJQUNBSCxPQUFPLENBQUNFLFFBQVIsQ0FBaUJFLE9BRGpCLElBRUFKLE9BQU8sQ0FBQ0ssT0FBUixDQUFnQixDQUFoQixDQUhGO0FBS0EsVUFBTUMsbUJBQW1CLEdBQUcsNEJBQzFCLHlCQUEyQk4sT0FBTyxDQUFDTyxXQUFSLEVBQTNCLEVBQWtETixrQkFBbEQsQ0FEMEIsQ0FBNUI7QUFJQSxVQUFNTyxNQUFNLEdBQUcsRUFBZjs7QUFFQSxhQUFTQyxJQUFULENBQWN2QixJQUFkLEVBQWdDO0FBQzlCLFlBQU07QUFBRXdCLFFBQUFBLE9BQUY7QUFBV0MsUUFBQUEsSUFBWDtBQUFpQkMsUUFBQUE7QUFBakIsVUFBd0MsbUJBQzVDMUIsSUFENEMsRUFFNUNvQixtQkFGNEMsRUFHNUMsSUFBSU8sR0FBSixDQUFRYixPQUFPLENBQUNFLFFBQVIsQ0FBaUJZLFNBQWpCLElBQThCLEVBQXRDLENBSDRDLENBQTlDOztBQU1BLFVBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQ1pGLFFBQUFBLE1BQU0sQ0FBQ08sSUFBUCxDQUFZO0FBQ1Y3QixVQUFBQSxJQURVO0FBRVY4QixVQUFBQSxPQUFPLEVBQUUsQ0FDUCw2QkFBa0JMLElBQWxCLENBRE8sRUFFUCxxQkFGTyxFQUdQQyxrQkFBa0IsQ0FBQ0ssSUFBbkIsQ0FBd0IsSUFBeEIsQ0FITyxFQUlQQSxJQUpPLENBSUYsR0FKRTtBQUZDLFNBQVo7QUFRRDtBQUNGOztBQUVELFVBQU1DLFdBQVcsR0FBRyxJQUFJTCxHQUFKLEVBQXBCO0FBRUEsV0FBTztBQUNMTSxNQUFBQSxjQUFjLEVBQUVWLElBRFg7QUFFTFcsTUFBQUEsZ0JBQWdCLEVBQUVYLElBRmI7QUFHTFksTUFBQUEsYUFBYSxFQUFFWixJQUhWOztBQUlMO0FBQ0FhLE1BQUFBLFVBQVUsQ0FBQ3BDLElBQUQsRUFBTztBQUNmLFlBQUlBLElBQUksQ0FBQ3FDLE1BQVQsRUFBaUI7QUFDZixnQkFBTTtBQUFFcEMsWUFBQUE7QUFBRixjQUFXRCxJQUFJLENBQUNxQyxNQUF0Qjs7QUFDQSxlQUNFO0FBQ0FwQyxVQUFBQSxJQUFJLEtBQUssVUFBVCxJQUNBO0FBQ0FBLFVBQUFBLElBQUksS0FBSyxxQkFGVCxJQUdBO0FBQ0FBLFVBQUFBLElBQUksS0FBSyxvQkFKVCxJQUtBO0FBQ0FBLFVBQUFBLElBQUksS0FBSyxrQkFOVCxJQU9BO0FBQ0FBLFVBQUFBLElBQUksS0FBSyx3QkFSVCxJQVNBO0FBQ0FBLFVBQUFBLElBQUksS0FBSyxpQkFWVCxJQVdBO0FBQ0FBLFVBQUFBLElBQUksS0FBSyxtQkFkWCxFQWVFO0FBQ0ErQixZQUFBQSxXQUFXLENBQUNNLEdBQVosQ0FBZ0J0QyxJQUFJLENBQUNHLElBQXJCO0FBQ0Q7QUFDRjtBQUNGLE9BM0JJOztBQTRCTCxzQkFBZ0IsTUFBTTtBQUNwQjtBQUNBO0FBQ0FtQixRQUFBQSxNQUFNLENBQ0hpQixNQURILENBQ1VDLEtBQUssSUFBSSxDQUFDUixXQUFXLENBQUNTLEdBQVosQ0FBZ0IxQyxPQUFPLENBQUN5QyxLQUFLLENBQUN4QyxJQUFQLENBQXZCLENBRHBCLEVBRUcwQyxPQUZILENBRVcxQyxJQUFJLElBQUljLE9BQU8sQ0FBQzZCLE1BQVIsQ0FBZTNDLElBQWYsQ0FGbkI7QUFHRDtBQWxDSSxLQUFQO0FBb0NEOztBQWpGWSxDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCBMaW50LCB7IGdlbmVyYXRlRXJyb3JOYW1lIH0gZnJvbSAnLi4vTGludCc7XG5pbXBvcnQgRGV0ZXJtaW5lVGFyZ2V0c0Zyb21Db25maWcsIHsgVmVyc2lvbmluZyB9IGZyb20gJy4uL1ZlcnNpb25pbmcnO1xuaW1wb3J0IHR5cGUgeyBFU0xpbnROb2RlIH0gZnJvbSAnLi4vTGludFR5cGVzJztcblxudHlwZSBFU0xpbnQgPSB7XG4gIFthc3ROb2RlVHlwZU5hbWU6IHN0cmluZ106IChub2RlOiBFU0xpbnROb2RlKSA9PiB2b2lkXG59O1xuXG50eXBlIENvbnRleHQgPSB7XG4gIG5vZGU6IEVTTGludE5vZGUsXG4gIHNldHRpbmdzOiB7XG4gICAgYnJvd3NlcnM6IEFycmF5PHN0cmluZz4sXG4gICAgcG9seWZpbGxzOiBBcnJheTxzdHJpbmc+XG4gIH0sXG4gIGdldEZpbGVuYW1lOiAoKSA9PiBzdHJpbmcsXG4gIHJlcG9ydDogKCkgPT4gdm9pZFxufTtcblxuZnVuY3Rpb24gZ2V0TmFtZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6IHtcbiAgICAgIHJldHVybiBub2RlLmNhbGxlZS5uYW1lO1xuICAgIH1cbiAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzoge1xuICAgICAgcmV0dXJuIG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgfVxuICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzoge1xuICAgICAgcmV0dXJuIG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBmb3VuZCcpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEJyb3dzZXJMaXN0Q29uZmlnID1cbiAgfCBBcnJheTxzdHJpbmc+XG4gIHwge1xuICAgICAgcHJvZHVjdGlvbj86IEFycmF5PHN0cmluZz4sXG4gICAgICBkZXZlbG9wbWVudD86IEFycmF5PHN0cmluZz5cbiAgICB9XG4gIHwgbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBtZXRhOiB7XG4gICAgZG9jczoge1xuICAgICAgZGVzY3JpcHRpb246ICdFbnN1cmUgY3Jvc3MtYnJvd3NlciBBUEkgY29tcGF0aWJpbGl0eScsXG4gICAgICBjYXRlZ29yeTogJ0NvbXBhdGliaWxpdHknLFxuICAgICAgcmVjb21tZW5kZWQ6IHRydWVcbiAgICB9LFxuICAgIGZpeGFibGU6ICdjb2RlJyxcbiAgICBzY2hlbWE6IFtdXG4gIH0sXG4gIGNyZWF0ZShjb250ZXh0OiBDb250ZXh0KTogRVNMaW50IHtcbiAgICAvLyBEZXRlcm1pbmUgbG93ZXN0IHRhcmdldHMgZnJvbSBicm93c2Vyc2xpc3QgY29uZmlnLCB3aGljaCByZWFkcyB1c2VyJ3NcbiAgICAvLyBwYWNrYWdlLmpzb24gY29uZmlnIHNlY3Rpb24uIFVzZSBjb25maWcgZnJvbSBlc2xpbnRyYyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIGNvbnN0IGJyb3dzZXJzbGlzdENvbmZpZzogQnJvd3Nlckxpc3RDb25maWcgPVxuICAgICAgY29udGV4dC5zZXR0aW5ncy5icm93c2VycyB8fFxuICAgICAgY29udGV4dC5zZXR0aW5ncy50YXJnZXRzIHx8XG4gICAgICBjb250ZXh0Lm9wdGlvbnNbMF07XG5cbiAgICBjb25zdCBicm93c2Vyc2xpc3RUYXJnZXRzID0gVmVyc2lvbmluZyhcbiAgICAgIERldGVybWluZVRhcmdldHNGcm9tQ29uZmlnKGNvbnRleHQuZ2V0RmlsZW5hbWUoKSwgYnJvd3NlcnNsaXN0Q29uZmlnKVxuICAgICk7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGxpbnQobm9kZTogRVNMaW50Tm9kZSkge1xuICAgICAgY29uc3QgeyBpc1ZhbGlkLCBydWxlLCB1bnN1cHBvcnRlZFRhcmdldHMgfSA9IExpbnQoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGJyb3dzZXJzbGlzdFRhcmdldHMsXG4gICAgICAgIG5ldyBTZXQoY29udGV4dC5zZXR0aW5ncy5wb2x5ZmlsbHMgfHwgW10pXG4gICAgICApO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck5hbWUocnVsZSksXG4gICAgICAgICAgICAnaXMgbm90IHN1cHBvcnRlZCBpbicsXG4gICAgICAgICAgICB1bnN1cHBvcnRlZFRhcmdldHMuam9pbignLCAnKVxuICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIENhbGxFeHByZXNzaW9uOiBsaW50LFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogbGludCxcbiAgICAgIE5ld0V4cHJlc3Npb246IGxpbnQsXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCB0aGUgZGVmaW5lZCB2YXJpYWJsZXMuIERvIG5vdCByZXBvcnQgZXJyb3JzIGZvciBub2RlcyB0aGF0IGFyZSBub3QgZGVmaW5lZFxuICAgICAgSWRlbnRpZmllcihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZXguIGNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbiAgICAgICAgICAgIHR5cGUgPT09ICdQcm9wZXJ0eScgfHxcbiAgICAgICAgICAgIC8vIGV4LiBmdW5jdGlvbiBTZXQoKSB7fVxuICAgICAgICAgICAgdHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgICAvLyBleC4gY29uc3QgU2V0ID0gKCkgPT4ge31cbiAgICAgICAgICAgIHR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8XG4gICAgICAgICAgICAvLyBleC4gY2xhc3MgU2V0IHt9XG4gICAgICAgICAgICB0eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicgfHxcbiAgICAgICAgICAgIC8vIGV4LiBpbXBvcnQgU2V0IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicgfHxcbiAgICAgICAgICAgIC8vIGV4LiBpbXBvcnQge1NldH0gZnJvbSAnc2V0JztcbiAgICAgICAgICAgIHR5cGUgPT09ICdJbXBvcnRTcGVjaWZpZXInIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IHtTZXR9IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSAnSW1wb3J0RGVjbGFyYXRpb24nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZGVudGlmaWVycy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnUHJvZ3JhbTpleGl0JzogKCkgPT4ge1xuICAgICAgICAvLyBHZXQgYSBtYXAgb2YgYWxsIHRoZSB2YXJpYWJsZXMgZGVmaW5lZCBpbiB0aGUgcm9vdCBzY29wZSAobm90IHRoZSBnbG9iYWwgc2NvcGUpXG4gICAgICAgIC8vIGNvbnN0IHZhcmlhYmxlc01hcCA9IGNvbnRleHQuZ2V0U2NvcGUoKS5jaGlsZFNjb3Blcy5tYXAoZSA9PiBlLnNldClbMF07XG4gICAgICAgIGVycm9yc1xuICAgICAgICAgIC5maWx0ZXIoZXJyb3IgPT4gIWlkZW50aWZpZXJzLmhhcyhnZXROYW1lKGVycm9yLm5vZGUpKSlcbiAgICAgICAgICAuZm9yRWFjaChub2RlID0+IGNvbnRleHQucmVwb3J0KG5vZGUpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuIl19